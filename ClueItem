ClueItem (Node2D)
│
├── Sprite2D
├── AudioStreamPlayer2D
└── (opcional) CollisionShape2D

extends Area2D
class_name ClueItem

# ============================================================
# SIGNALS
# ============================================================
signal revealed
signal collected
signal used  # novo sinal para portas ou interações

# ============================================================
# CONFIGURAÇÕES
# ============================================================
@export_category("Clue Behavior")
@export var collectible := true
@export var destroy_on_collect := true

@export_category("Light Reaction")
@export var min_visible_energy := 0.4
@export var fade_speed := 4.0

@export_category("Diary")
@export var diary_page: DiaryPageData

@export_category("Dialogue")
@export var dialogue_id: String = ""

@export_category("Door / Scene")
@export var target_scene: String = ""  # se preenchido, ClueItem funciona como porta
@export var requires_light: bool = false  # porta só funciona se iluminada

@export_category("References")
@export var lantern_path: NodePath

# ============================================================
# ESTADO
# ============================================================
var lantern
var was_revealed := false
var light_reactive := LightReactive.new()
var can_use := false  # usado para portas

# ============================================================
# NODES
# ============================================================
@onready var sprite: Sprite2D = $Sprite2D
@onready var audio: AudioStreamPlayer2D = $AudioStreamPlayer2D

# ============================================================
# READY
# ============================================================
func _ready():
    lantern = get_node_or_null(lantern_path)
    sprite.modulate.a = 0.0

    if lantern:
        lantern.light_updated.connect(_on_lantern_light_updated)

    # conecta coleta apenas se for coletável ou porta
    if collectible or target_scene != "":
        body_entered.connect(_on_body_entered)

# ============================================================
# LANTERN CALLBACK
# ============================================================
func _on_lantern_light_updated(pos: Vector2, radius: float, energy: float):
    light_reactive.process_light(
        get_process_delta_time(),
        pos,
        radius,
        energy,
        global_position,
        sprite
    )

    can_use = light_reactive.is_illuminated

    if can_use and not was_revealed:
        was_revealed = true
        emit_signal("revealed")
        _trigger_dialogue()

# ============================================================
# INTERAÇÃO / COLETA / PORTA
# ============================================================
func _on_body_entered(body):
    if not body.is_in_group("player"):
        return

    # porta: só funciona se iluminada (se require_light)
    if target_scene != "" and requires_light and not can_use:
        return

    emit_signal("collected")
    emit_signal("used")
    _trigger_dialogue()

    # envia página para DiaryManager global (se houver)
    if diary_page:
        DiaryManager.add_page(diary_page)

    # muda de cena se target_scene preenchido
    if target_scene != "":
        get_tree().change_scene(target_scene)

    if collectible and destroy_on_collect:
        queue_free()

# ============================================================
# DIÁLOGO
# ============================================================
func _trigger_dialogue():
    if dialogue_id != "":
        DialogueManager.show_dialogue(dialogue_id)

